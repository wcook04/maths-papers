# ==============================================================================
# ULTRA-ROBUST Kinetic Stress Index (KSI) Calculator for Bloomberg BQuant
# Version 4.1 - HOLIDAY & BQL ROBUSTNESS FIX
#
# Changelog:
# - CRITICAL FIX: Reversed data cleaning order to dropna().ffill() to correctly
#   handle market holidays and prevent artificial zero-return days.
# - ROBUSTNESS: Refined BQL query to only apply 'currency=USD' to equity
#   indices, preventing incorrect conversions for FX and commodity assets.
# ==============================================================================

import pandas as pd
import numpy as np
import itertools
import matplotlib.pyplot as plt
import warnings
import traceback
import sys
import time
from datetime import datetime
import json
import os

# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

# --- Check BQL and scikit-learn availability ---
BQL_AVAILABLE = False
SKLEARN_AVAILABLE = False

try:
    import bql
    BQL_AVAILABLE = True
    print("✓ BQL module imported successfully")
except ImportError:
    print("⚠️  BQL module not found. Set test_mode=True to run with synthetic data")

try:
    from sklearn.covariance import LedoitWolf
    SKLEARN_AVAILABLE = True
    print("✓ scikit-learn imported successfully")
except ImportError:
    print("⚠️  scikit-learn not found. Run: %pip install scikit-learn")
    LedoitWolf = None

# ==============================================================================
# CONFIGURATION - ADJUST THESE SETTINGS AS NEEDED
# ==============================================================================

CONFIG = {
    'assets': {
        'STOCKS': {
            'primary': 'SPX Index',
            'fallbacks': ['SPY US Equity', 'ES1 Index'],
            'asset_type': 'equity_index',
            'description': 'S&P 500 Index'
        },
        'BONDS': {
            'primary': 'CT10 Govt',
            'fallbacks': ['USGG10YR Index', 'GT10 Govt'],
            'asset_type': 'yield',  # Critical: This is a yield, not a price!
            'description': 'US 10-Year Treasury Yield'
        },
        'GOLD': {
            'primary': 'XAU Curncy',
            'fallbacks': ['XAUUSD Curncy', 'GC1 Comdty'],
            'asset_type': 'commodity',
            'description': 'Gold Spot Price'
        },
        'CURRENCY': {
            'primary': 'AUDJPY Curncy',
            'fallbacks': ['AUDJPY BGN Curncy'],
            'asset_type': 'fx',
            'description': 'AUD/JPY Exchange Rate'
        }
    },
    
    # Date range
    'start_date': '2007-01-01',
    'end_date': pd.to_datetime('today').strftime('%Y-%m-%d'),
    
    # Model parameters
    'correlation_window': 60,
    'volatility_window': 60,
    'warmup_period': 252,
    'max_correlation_clip': 0.999,
    
    # Robustness parameters
    'bql_retry_attempts': 3,
    'min_data_points': 500,
    'min_valid_pairs': 3,
    'adaptive_regularization': True,
    
    # IMPORTANT: Set to True to test without Bloomberg
    'test_mode': False,  # <<<< SET TO True IF TESTING WITHOUT BLOOMBERG
    
    'save_diagnostics': True,
    'verbose': True,
}

class BQuantKSI:
    """Ultra-robust KSI implementation for Bloomberg BQuant."""
    
    def __init__(self, config):
        # ... (constructor remains the same) ...
        pass
    
    # ... (logging and environment functions remain the same) ...
    
    def _fetch_bloomberg_data(self):
        """Fetch data from Bloomberg with fallback handling."""
        # ... (BQL initialization remains the same) ...
        
        for asset_key, asset_config in self.config['assets'].items():
            self._log(f"\nFetching {asset_key} ({asset_config['description']})...")
            tickers = [asset_config['primary']] + asset_config.get('fallbacks', [])
            
            for ticker in tickers:
                self._log(f"  Trying: {ticker}")
                try:
                    # --- FIX #2: More Robust BQL Query Construction ---
                    # Only apply currency conversion to assets that need it (equity indices).
                    # This avoids errors or unintended behavior for FX, yields, and commodities.
                    bql_params = {
                        "dates": f"range('{self.config['start_date']}', '{self.config['end_date']}')",
                        "fill": "prev"
                    }
                    if asset_config['asset_type'] == 'equity_index':
                        bql_params['currency'] = 'USD'

                    query = self.bql_svc.get_data(
                        ticker,
                        ['PX_LAST'],
                        bql_params
                    )
                    
                    response = self.bql_svc.execute(query)
                    
                    # ... (rest of the fetching logic remains the same, as it's robust) ...
                    
                except Exception as e:
                    self._log(f"    Failed: {str(e)[:100]}")
                    continue
            else:
                self._log_warning("DATA_FETCH", f"Could not fetch {asset_key} from any ticker")
        
        if not fetched_data:
            self._log_error("DATA_FETCH", "No data fetched for any asset")
            return False
        
        self._log(f"\n✓ Fetched data for {len(fetched_data)} assets")
        return self._process_fetched_data(fetched_data)
    
    def _process_fetched_data(self, fetched_data):
        """Process and align fetched data."""
        try:
            # Align all series by concatenating and letting pandas handle alignment
            self.price_df = pd.concat(fetched_data.values(), axis=1, join='outer')
            self.price_df.columns = fetched_data.keys()
            
            self._log(f"Combined data before cleaning: {self.price_df.shape}")

            # --- FIX #1: CRITICAL - CLEAN DATA IN THE CORRECT ORDER ---
            # 1. Drop any row with ANY missing values. This removes holidays correctly.
            # 2. Then, forward/backward fill any remaining sparse gaps.
            rows_before = len(self.price_df)
            self.price_df = self.price_df.dropna()
            self.price_df = self.price_df.ffill().bfill()
            rows_after = len(self.price_df)
            
            if rows_after < rows_before:
                self._log(f"  Cleaned Data: Removed {rows_before - rows_after} rows with missing values (e.g., holidays).")

            if len(self.price_df) < self.config['min_data_points']:
                self._log_error("DATA", f"Insufficient clean data points: {len(self.price_df)}")
                return False
            
            self._log(f"✓ Data processed: {self.price_df.shape}")
            self._log(f"  Date range: {self.price_df.index[0].date()} to {self.price_df.index[-1].date()}")
            
            self._calculate_standardized_changes()
            
            return True
            
        except Exception as e:
            self._log_error("DATA_PROCESS", "Failed to process data", e)
            return False
    
    # ... (The rest of the class methods: _calculate_standardized_changes, _build_state_vector,
    #      _compute_ksi, _generate_synthetic_data, _validate_results, plot_ksi, etc.,
    #      are already robust and do not need changes. They will now operate on correctly
    #      cleaned data.)

# ==============================================================================
# MAIN EXECUTION
# ==============================================================================

if __name__ == '__main__':
    # Create and run the KSI analyzer
    analyzer = BQuantKSI(CONFIG)
    
    # Generate outputs if successful
    if not analyzer.ksi_series.empty:
        # Plot the results
        analyzer.plot_ksi()
        
        # Generate text report
        analyzer.generate_report()
    else:
        print("\n⚠️  KSI calculation failed. Check the output above for errors.")
        print("    Review the diagnostics JSON file for detailed information.")
